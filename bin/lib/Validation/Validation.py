import os
import re

from ..Support import Utilities

def test(lang, file_manager, tool, line_numbers, forced_lines, description, \
         indices, initial_fname=None, check_forced=True, classpath=None, sourcepath=None):
    """Tests the debugging algorith. It returns False if it FAILS.

    Arguments:
    file_manager -- file manager object with the info of the file to process
    tool -- SCA tool object 
    line_numbers -- list of the line numbers that are failing
    forced_lines -- lines that must be in the snippet (not producing SCA warn)
    description -- warning generated by the SCA tool
    indices -- indices of the lines of the file to be reduced
    initial_fname -- if set, use this file to perform the test
    check_forced -- check forced lines
    """
    if not indices:
        return True

    if check_forced and not Utilities.is_subset(forced_lines, indices):
        return True

    compiler = tool.get_compiler()
    original_fname = file_manager.get_source_path()
    if initial_fname:
        fname = initial_fname
    else:
        fname = file_manager.get_trial_source_path()
        
    if lang == 'java':
        result = compiler.compile(original_fname, fname, \
                              file_manager.get_build_dir(), classpath, sourcepath)
    elif lang == 'c':
        result = compiler.compile(original_fname, \
                              file_manager.get_build_object_path(), 
                              fname)

    if result == 0:
        failed = False
        if lang == 'java':
            tool.handle_compile_file(file_manager.get_build_class_path(), \
                                     compiler.get_command(original_fname), \
                                     classpath=classpath, sourcepath=sourcepath)
        elif lang == 'c':
            tool.handle_compile_file(original_fname, \
                                 fname, \
                                 compiler.get_command(original_fname))
        parsed_output = tool.get_tool_output(filtered=False)
        for (file_name, lines, _, desc) in parsed_output:
            # TODO: include multiple lines like in M B NP: com.javacodegeeks.example.findBugsPluginExample.OfConcernRankBugs.equals(Object) does not check for null argument  At OfConcernRankBugs.java:[lines 32-33]
            if (len(lines)) > 1:
                continue
            fname1 = os.path.basename(file_name)
            fname2 = os.path.basename(file_manager.get_original_source_path())
            equal_description = True
            if description:
                desc1 = re.sub(r'line \d+', 'line X', description).strip()
                desc2 = re.sub(r'line \d+', 'line X', desc).strip()
                if '?' in desc1 or '?' in desc2:
                    equal_description = are_equal_but(desc1, desc2, '?')
                else:
                    equal_description = desc1 == desc2
            if fname1 == fname2 and \
                    check_indices(indices, line_numbers, lines) and \
                    equal_description:
                failed = True
                break

        return not failed
    else:
        return True


def are_equal_but(desc1, desc2, character):
    split1 = desc1.split()
    split2 = desc2.split()
    are_equal = len(split1) == len(split2)
    i = 0
    while i < len(split1) and are_equal:
        are_equal = split1[i] == split2[i]
        if not are_equal:
            if split1[i] == character or split2[i] == character:
                are_equal = True
        i += 1
    return are_equal


def check_indices(indices, orig_line_numbers, lines):
    """Checks whether the indices generated the same warning.

    Arguments:
    indices -- indices of the lines of the file to be reduced
    orig_line_numbers -- line numbers originally generating the warning
    lines -- line numbers where a warning was generated for the trial file
    """

    tmp = list(map(lambda x: indices[x - 1], lines))
    res = tmp == orig_line_numbers

    #
    # findbugs sometimes does not include one
    # line that should be included
    # This horrible stuff is just in case we have something like [4,5,6,7]
    # and [5,6,7]. This is because some tools may not include a line.
    #
    if not res and len(tmp) > 1 and len(orig_line_numbers) > 1:
        chunk_ln = orig_line_numbers[:]
        if tmp[1] == chunk_ln[0]:
            tmp = tmp[1:]
        elif tmp[0] == chunk_ln[1]:
            chunk_ln = chunk_ln[1:]
        if len(tmp) > 1 and len(chunk_ln) > 1:
            if tmp[-1] == chunk_ln[-2]:
                chunk_ln = chunk_ln[:-1]
            elif tmp[-2] == chunk_ln[-1]:
                tmp = tmp[:-1]
        res = tmp == chunk_ln
    return res
