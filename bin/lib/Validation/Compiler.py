import sys
import os
import subprocess
import shutil
import re

import json
import fnmatch
import logging


class Compiler:

    def __init__(self, data):
        self.__compilation_data = data

    @classmethod
    def from_file(cls, fname):
        """Creates the compiler from a compile_commands.json file as the one 
        generated by cmake

        Arguments:
        fname - compile_commands.json file
        """
        # [{'command': '...', 'directory': '...', 'file': '...'}, {'command': '...', 'directory': '...', 'file': '...'}, ... ]
        with open(fname, 'r') as json_data:
            data = json.load(json_data)
        return cls(data)

    @classmethod
    def from_command(cls, compiler, options=None):
        """Creates the compiler from a compiler name and a set of options 

        Arguments:
        compiler - compiler name. e.x. "g++"
        options - options of the compiler. e.x. "-I/usr/lib/library"
        """
        command = compiler + ' '
        if options: command += options + ' '
        command += '-o *.o -c *.c'
        data = [{'command': command, 'directory': '', 'file': '*'}]
        return cls(data)

    def get_files(self):
        """Get the list of files that can be compiled with the current object
        """
        res = []
        for entry in self.__compilation_data:
            res.append(entry['file'])
        return res

    def get_command(self, fname):
        """Get the command to compile a specific file
        """
        for entry in self.__compilation_data:
            if fnmatch.fnmatch(fname, entry['file']):
                return entry['command']
        return None

    def compile(self, original_fname, object_file, source_file):
        """Compile a file.

        Arguments:
        original_fname - original file name to be compiled
        object_file - object file name to be generated
        source_file - copy of the original file that is the actually compiled
        """
        compilation = None
        dirname = os.path.dirname(original_fname)
        fname = os.path.basename(original_fname)
        for file_compilation in self.__compilation_data:
            # we allow wildcards in the 'file' field of the json compile_commands
            # TODO: do we want wildcards here? Test them at least :P
            if fnmatch.fnmatch(original_fname, file_compilation['file']):
                if dirname != os.path.dirname(file_compilation['directory']):
                    #TODO: should we cd to dirname???
                    pass

                # replacing -o fname.o
                command = file_compilation['command']
                matching = re.search(r"-o\s+.+\.o", command)
                if matching:
                    (a, b) = matching.span()
                    command = command[:a] + "-o " + object_file + \
                                command[b:]

                # replacing -c fname.c
                matching = re.search(r"-c\s+.+\.c(?:xx|pp|\+\+)?", command)
                if matching:
                    (a, b) = matching.span()
                    command = command[:a] + "-c " + source_file + \
                                command[b:]
                else:
                    command += source_file

                # try to compile it
                try:
                    output = subprocess.check_output(command, \
                                                     stderr=subprocess.STDOUT, \
                                                     shell=True)
                    logging.debug("Compilation of file [%s] was successful with [%s]" \
                                  % (fname, command))
                    return 0
                except subprocess.CalledProcessError as _:
                    logging.debug("Compilation of file [%s] FAILED with command [%s]" \
                                  % (fname, command))
                    return 1


if __name__ == "__main__":
    import shutil
    import sys
    compiler = Compiler.from_file(sys.argv[1])
    out_folder = sys.argv[2]
    i = 0
    for fname in compiler.get_files():
        if not os.path.exists(fname):
            continue
        out_file = os.path.join(out_folder, str(i))
        cfile = out_file + '.c'
        ofile = out_file + '.o'
        shutil.copyfile(fname, cfile)
        res = compiler.compile(fname, ofile, cfile)
        if res == 0:
            print (fname + " compiled successfully as " + cfile)
        else:
            print ("FAILED to compile " + fname + " as " + cfile)
        i += 1
