################################################################################
#
# file : CppCheck.py
#
# author: Matias Marenchino - mlmarenchino@gmail.com
#         (based on code by Lakshmi Manohar Rao Velicheti - lveliche@iupui.edu)
##
################################################################################


from .Tool import Tool
from ..Support import Utilities
from .JulietCppLineno2Fname import lineno2fun
from ..Validation.Compiler import Compiler

import logging

import os
import sys
import csv
import socket
import collections
import struct
import re
import subprocess


CPPCHECK_PATH = "/Users/mlmarenchino/Programs/cppcheck-1.68/"


def __create__ ():
  return CppCheck ()

#
# Worker function for multithreaded analysis
#
def run_worker (truth, tool, tool_name):
  return CppCheck ().handle_weakness (truth, tool, tool_name)

#
# Concrete class for CppCheck
#
class CppCheck (Tool):
  #
  # Name of the tool
  #
  @staticmethod
  def name ():
    return 'cppcheck'

  #
  # A description of the methodology for this Tool
  #
  def methodology (self, args, document):
    args_dict = Utilities.dictify_args (args)
    document.add_paragraph ('''
CppCheck, description...
#'codesonar analyze [project_name] -foreground [server] [compiler] [args]'
'cppcheck ....'
''')

#TODO: the rest of the document
#     document.add_paragraph ('''
# To build the checker to CWE mapping, the documentation provided with CodeSonar
# at http://[server]/install/codesonar/doc/html/WarningClasses/CWE/CWEbyID.html
# was used.''')

#     if args_dict['weaknesses'] == None:
#       document.add_paragraph ('''
# This report included all CWEs which were used for the Import process.

# A full listing of the class (checkers) to CWE mapping is as follows:
# ''')
#       for (cwe, mapping) in self.__mapping__.items ():
#         document.add_paragraph ('%s: %s' % (cwe, ', '.join (mapping)), style='ListBullet')
#     else:
#       document.add_paragraph ('''
# The following CWEs were built for this tool's results with their respective
# class (checkers) to CWE mapping:''')
#       for cwe in args_dict['weaknesses'].split (','):
#         document.add_paragraph ('%s: %s' % (cwe, ', '.join (self.__mapping__[cwe])), style='ListBullet')

  #
  # Initialize the parser
  #
  @staticmethod
  def init_parser (parser):
    cppcheck_parser = parser.add_parser ('CppCheck', help='Use the CppCheck tool')
    cppcheck_parser.set_defaults (tool=CppCheck)

    group = cppcheck_parser.add_mutually_exclusive_group(required=True)
    group.add_argument('--compile-commands', type=str, help='json file as generated by cmake')
    group.add_argument('--compiler', type=str, help='compiler to compile the files')

    cppcheck_parser.add_argument ('--options', type=str, help='options to compile the file')
    cppcheck_parser.add_argument ('--results-dir', type=str, help='Directory to store the results')


  #
  # Initalize the tool
  #
  def init (self, args):
    # Call the base class (Command) init
    super (CppCheck, self).init (args)

    self.__SCATE_root__ = os.path.realpath (os.path.join (os.path.dirname (__file__), '../../'))
    self.__facts__ = []
    self.__sca_output__ = []
    self.__results_dir__ = args.results_dir

    if args.compile_commands:
      self.__compiler = Compiler.from_file(args.compile_commands)
    else:
      self.__compiler = Compiler.from_command(args.compiler, args.options)


  #
  # Python ctor
  #
  def __init__ (self):
    # TODO: Find the CWE by the IDs. Currently set to I Dont Know
    self.__mapping__ = collections.OrderedDict (sorted ({
                        'CWE114': ['IDK'],
                        'CWE126': ['IDK'],
                        'CWE190': ['IDK'],
                        'CWE197': ['IDK'],
                        'CWE23':  ['IDK'],
                        'CWE253': ['IDK'],
                        'CWE284': ['IDK'],
                        'CWE327': ['IDK'],
                        'CWE366': ['IDK'],
                        'CWE390': ['IDK'],
                        'CWE398': ['IDK'],
                        'CWE416': ['IDK'],
                        'CWE459': ['IDK'],
                        'CWE475': ['IDK'],
                        'CWE481': ['IDK'],
                        'CWE500': ['IDK'],
                        'CWE535': ['IDK'],
                        'CWE562': ['IDK'],
                        'CWE588': ['IDK'],
                        'CWE617': ['IDK'],
                        'CWE674': ['IDK'],
                        'CWE688': ['IDK'],
                        'CWE773': ['IDK'],
                        'CWE789': ['IDK'],
                        'CWE121': ['IDK'],
                        'CWE127': ['IDK'],
                        'CWE191': ['IDK'],
                        'CWE204': ['IDK'],
                        'CWE242': ['IDK'],
                        'CWE256': ['IDK'],
                        'CWE304': ['IDK'],
                        'CWE328': ['IDK'],
                        'CWE367': ['IDK'],
                        'CWE391': ['IDK'],
                        'CWE400': ['IDK'],
                        'CWE426': ['IDK'],
                        'CWE464': ['IDK'],
                        'CWE476': ['IDK'],
                        'CWE482': ['IDK'],
                        'CWE506': ['IDK'],
                        'CWE546': ['IDK'],
                        'CWE563': ['IDK'],
                        'CWE590': ['IDK'],
                        'CWE620': ['IDK'],
                        'CWE675': ['IDK'],
                        'CWE690': ['IDK'],
                        'CWE775': ['IDK'],
                        'CWE832': ['IDK'],
                        'CWE122': ['IDK'],
                        'CWE134': ['IDK'],
                        'CWE194': ['IDK'],
                        'CWE222': ['IDK'],
                        'CWE244': ['IDK'],
                        'CWE259': ['IDK'],
                        'CWE319': ['IDK'],
                        'CWE338': ['IDK'],
                        'CWE369': ['IDK'],
                        'CWE392': ['IDK'],
                        'CWE401': ['IDK'],
                        'CWE427': ['IDK'],
                        'CWE467': ['IDK'],
                        'CWE478': ['IDK'],
                        'CWE483': ['IDK'],
                        'CWE510': ['IDK'],
                        'CWE547': ['IDK'],
                        'CWE570': ['IDK'],
                        'CWE591': ['IDK'],
                        'CWE665': ['IDK'],
                        'CWE676': ['IDK'],
                        'CWE758': ['IDK'],
                        'CWE78':  ['IDK'],
                        'CWE835': ['IDK'],
                        'CWE123': ['IDK'],
                        'CWE15':  ['IDK'],
                        'CWE195': ['IDK'],
                        'CWE223': ['IDK'],
                        'CWE247': ['IDK'],
                        'CWE272': ['IDK'],
                        'CWE321': ['IDK'],
                        'CWE36':  ['IDK'],
                        'CWE374': ['IDK'],
                        'CWE396': ['IDK'],
                        'CWE404': ['IDK'],
                        'CWE440': ['IDK'],
                        'CWE468': ['IDK'],
                        'CWE479': ['IDK'],
                        'CWE484': ['IDK'],
                        'CWE511': ['IDK'],
                        'CWE560': ['IDK'],
                        'CWE571': ['IDK'],
                        'CWE605': ['IDK'],
                        'CWE666': ['IDK'],
                        'CWE680': ['IDK'],
                        'CWE761': ['IDK'],
                        'CWE780': ['IDK'],
                        'CWE843': ['IDK'],
                        'CWE124': ['IDK'],
                        'CWE188': ['IDK'],
                        'CWE196': ['IDK'],
                        'CWE226': ['IDK'],
                        'CWE252': ['IDK'],
                        'CWE273': ['IDK'],
                        'CWE325': ['IDK'],
                        'CWE364': ['IDK'],
                        'CWE377': ['IDK'],
                        'CWE397': ['IDK'],
                        'CWE415': ['IDK'],
                        'CWE457': ['IDK'],
                        'CWE469': ['IDK'],
                        'CWE480': ['IDK'],
                        'CWE489': ['IDK'],
                        'CWE534': ['IDK'],
                        'CWE561': ['IDK'],
                        'CWE587': ['IDK'],
                        'CWE606': ['IDK'],
                        'CWE672': ['IDK'],
                        'CWE685': ['IDK'],
                        'CWE762': ['IDK'],
                        'CWE785': ['IDK'],
    }.items (), key=lambda t: t[0]))

  # {@ Build hooks

  #
  # Determine if CppCheck supports a weakness
  #
  def supports_weakness (self, weakness):
    return weakness.name in self.__mapping__.keys ()

  #
  # Provides the correct result set for CppCheck
  #
  def build_result_set (self):
    return ResultSet ('resultset', 'cppcheck')

  #
  # Handle clean
  #
  def handle_clean (self, suite):
    logging.info ('Cleaning suite [%s]' % suite.directory)
    logging.info ('This suite cannot be cleaned')

  #
  # Compile the weakness using CppCheck Tool
  #
  def handle_compile (self, suite, ):
    logging.info ('Compiling suite [%s] with tool [%s]' % (suite.directory, self.name ()))

    # Get into the correct directory
    suite_dir = os.path.abspath (os.path.join (self.__SCATE_root__, suite.directory ))

    logging.info ('Running CppCheck (may take some time) ...')
    for filename in os.listdir(suite_dir):
      if filename.endswith (".c") and not filename.startswith ('main'):
        if ('w32' in filename or 'wchar_t' in filename):
          logging.debug ('Skipping import for w32 file [%s]' % filename)
        else:
          filepath = os.path.relpath(suite_dir, self.__SCATE_root__)
          filepath = os.path.join(filepath, filename)
          self.handle_compile_file(filepath, concat_output=True)

  # 
  # Compile just a single file in the local computer
  # 
  def get_compiler (self):
    return self.__compiler

  # 
  # Compile just a single file
  # 
  def handle_compile_file (self, filepath, options=None, concat_output=False):
    self.run_cppcheck(filepath, options, concat_output)

  #
  # Get a unique project name for the provided suite
  #
  def get_project_name (self, suite):
    # Just use the suite directory, since that is unique
    return suite.directory

  #
  # Gather results from the server into the provided result set
  #
  def handle_docgen (self, suite):
    # Get build numbers and project name from the index

    # TODO
    # parse it: :)
    logging.info ('Generating build results for suite [%s]' % suite.directory)
    # Get the analysis results
    # analysis = self.get_from_server ('http://%s%s' % (self.__server__, project_info[project_name]['url']))
    for warning in self.get_tool_output():
      # example: (file, ln, function, description)
      prob_info = warning[3]
      filename = os.path.basename(warning[0])
      line = warning[1][0]
      procedure = warning[2]
      if '::' in procedure:
        bug = Bug (filename, procedure.split ('::')[1], line, prob_info)
      else:
        bug = Bug (filename, procedure, line, prob_info)
      suite.bugs.append (bug)

    logging.info ('Found [%s] bugs for suite [%s]' % (len (suite.bugs), suite.directory))
    self.__sca_output__ = []
  # @}

  # {@ Analyze Hooks

  #
  # Determine if a checker is correct for a CWE
  #
  def correct_checker (self, bug, weakness):
    if not weakness in self.__mapping__.keys ():
      return False

    if bug.probability_info in self.__mapping__[weakness]:
      return True
    return False

  # @}

  #
  # Build reports using the appropriate
  # type of report generator
  #
  def report(self,type_,csv_input,ignore_error_flag):
    reportgenerators = Utilities.get_reportgenerators()
    if ignore_error_flag == False:
      print ("\nCurrently we have the functionality to capture and generate this inforamtion\nbut it needs to be integrated into our framework\nThanks for your patience")
    else:
      for generator in reportgenerators:
        if type_ == generator.name():
          generator.init(csv_input)
          generator.generatereport()

  # 
  # Parses the output of cppcheck given in a string.
  # The output has the following format (example of a line):
  #     [CWE758_Undefined_Behavior__struct_malloc_use_18.c:26]: (error) Data is allocated but not initialized: pointer
  def parse_cppcheck_output(self, output):
    res = []
    line2fun = None
    output = output.decode('utf-8')
    for line in output.split('\n'):
      line = line.strip()
      m = re.match(r"\[(.+):(\d+)\]: \((.*)\) (.*)", line)
      if m:
        fname = m.groups()[0]
        ln = int(m.groups()[1])
        desc = m.groups()[3].strip()
        desc = re.sub(r"at line (\d+)", r"****at certain line****", desc)
        if not line2fun:
          line2fun = lineno2fun(fname)
        res.append((fname, [ln], line2fun[ln], desc))

    return res


  def run_cppcheck(self, fname, options=None, concat_output=False):
    logging.debug('Running CppCheck on file [%s]' % fname)
    #TODO:
    cmd = CPPCHECK_PATH + "cppcheck --force --inline-suppr -q -I . "
    if options:
      tmp = re.findall(r'-D\S+', options)
      tmp += re.findall(r'-I\S+', options)
      tmp += re.findall(r'-I\s+[^ \t\n\r\f\v-]+', options)
      cmd += " " + " ".join(tmp) + " "

    cmd += fname
    cmd += ' 2>&1'

    output = ""
    try:
      # TODO: this could be a util
      output = subprocess.check_output(cmd, shell=True)
      logging.debug("cppcheck output: [%s]" % output.decode('utf-8'))
    except subprocess.CalledProcessError as outexc:
      logging.error("ERROR: Unable to run cppcheck on file [%s]. Failing command [%s]" \
                    % (fname, cmd))

    if not concat_output:
      self.__sca_output__ = []
    if output: 
      self.__sca_output__.extend(self.parse_cppcheck_output(output))

  # 
  # Returns the output of cppcheck.
  # if filtered is set to True, it just includes a 
  # single warning for every line 
  # (in case a line has more than one warning)
  # 
  def get_tool_output(self, filtered=True):
    if filtered:
      tmp_hash = {}
      for (fname, ln, function, desc) in self.__sca_output__:
        ln = str(ln)
        if fname not in tmp_hash:
          tmp_hash[fname] = {}
        if ln not in tmp_hash[fname]:
          tmp_hash[fname][ln] = (function, desc)
        else:
          # use the first description (lexicographically ordered)
          if tmp_hash[fname][ln][0] > function:
            tmp_hash[fname][ln] = (function, desc)
      self.__sca_output__ = []
      for fname in tmp_hash:
        for ln in tmp_hash[fname]:
          self.__sca_output__.append((fname, eval(ln), \
                    tmp_hash[fname][ln][0], tmp_hash[fname][ln][1]))
    # logging.info("cppcheck filtered output: [%s]" % self.__sca_output__)
    return self.__sca_output__

